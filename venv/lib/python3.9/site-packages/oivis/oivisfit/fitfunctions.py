"""
collection of functions parametrized by dictionnaries, to allow easy fitting
of visibility and closure phase functions with visfit module

author: Jean-Philippe.Berger@univ-grenoble-alpes.fr
"""
# TODO document properly the functions including updated examples

import numpy as np
from scipy.special import j0, j1, jv
import sys
thismod = sys.modules[__name__]


def combine_functions(x, params):
    """Allows to call any combination of function defined inside visfuncs to create an object and compute visibility and flux

    visdat = vis_combine_functions(x, params)

    params={'funcA;1:p1':, 'funcA;1:p2':, 'funcA;2:p1':, 'funcA;2:p2':, 'funcB:p1':, etc}
    funcA and funcB should be defined in visfuncs.py. Allows to call
    many instances of the same function (here funcA) and combine
    different functions.  Outputs of the difference functions will be
    sumed usinf operator '+'.

    Parameters
    ----------
    x : np.array

            x[0]: u coordinate array

            x[1]: v coordinate array

            x[2]: effective wavelength coordinate

            x[3]: reference wavelength

    params : dictionary
            'funcA;1:p1': .., 'funcA;1:p2':.., 'funcA;2:p1':, 'funcA;2:p2':, 'funcB:p1':, etc}

    Returns
    -------
    visdat : dictionary
        visdat['VIS']  flux weighted complex visibility  for each uv point

        visdat['FLUX'] flux for each uv point

    Examples
    --------

        >>> visdat = vis_combine_functions(x, params)

    """

    # -- list of functions:
    funcs = set([k.strip().split(':')[0].strip() for k in params.keys()])
    vis = 0
    flux = 0
    totalflux = 0
    for f in funcs:  # for each function
        # -- keep only relevant keywords
        kz = filter(lambda k: k.strip().split(':')[0].strip() == f,
                    params.keys())
        tmp = {}
        for k in kz:
            # -- build temporary dict pf parameters
            paramname = k.split(':')[1].strip()
            if paramname == 'FLUX':
                totalflux += params[k]
            tmp[k.split(':')[1].strip()] = params[k]
        ff = f.split(';')[0].strip()  # actual function name
        #print("Call for function {0}".format(ff))
        #        if not fitfuncs.__dict__.has_key(ff):
        #        if not thismod.__dict__.has_key(ff):
        # python 3 way
        if ff not in thismod.__dict__:
            raise NameError(ff + ' not defined in fitfuncs')
        # -- add to result the function result
        vis += thismod.__dict__[ff](x, tmp)['VIS']
        flux += thismod.__dict__[ff](x, tmp)['FLUX']
        #        res += fitfuncs.__dict__[ff](x, tmp)
    visdat = {}
    visdat['VIS'] = vis / flux
    visdat['FLUX'] = flux

    return visdat

def compute_closure_phase(y, fitfunc, params):
    """

    :param y:
    :param function:
    :param fitfunc:
    :param params:
    :param module:
    :return:
    """

    # Extracting u and v for the 3 baselines
    x1 = [y[0], y[1], y[4], y[5]]
    x2 = [y[2], y[3], y[4], y[5]]
    x3 = [-y[0] - y[2], -y[1] - y[3], y[4], y[5]]

    visfunc = getattr(thismod, fitfunc)
    vis1 = visfunc(x1, params)['VIS']
    vis2 = visfunc(x2, params)['VIS']
    vis3 = visfunc(x3, params)['VIS']

    bispectrum = vis1 * vis2 * vis3

    return np.arctan2(np.imag(bispectrum), np.real(bispectrum)) / np.pi * 180.0


def vis_uniform_disk(x, params):
    '''vis_uniform_disk Computes the complex isibility and flux for a uniform disk.
    
    :param x: uv coordinates and wavelength
        x[0]: array of float (meters)
            U coordinates
        x[1]: array of float (meters)
            V coordinates
        x[2]: array of float (micron)
            Wavelength (same dim as X[0]
        x[3]: float (micron)
            Reference wavelength (for spectral index)
    :type x: 4D np.array

    :param params: Parameters describing the morphology
        params['POSANG'] : float (in radians)
            Position angle (north from east of ring major axis)
        params['FLUX'] : float
            total flux of the structure
        params['SPI'] : float
            spectral index (applied as (waveref/wave)**spi)
        params['OFX'] : float (radians)
            offset in the right ascension direction
        params['OFY'] : float (radians)
            offset in the declinaiton direction
        params['DIAM'] : float (radians)
            Diameter of the uniform disk.
        params['ERATIO'] : float
            major/minor axis ratio (although will not mind if its the
            reverse (minor/major)
    :type params: Dictionary

    :return: visdat dictionary
        visdat['VIS'] : complex visibility array of same dimension as
        the u,v coverage provided in the x array
        visdat['FLUX'] : spectral index corrected flux at each
        wavelength (same dim as VIS

    :Example:

    '''
    flux = params['FLUX']
    ofx = params['OFX']
    ofy = params['OFY']
    posang = params['POSANG']
    diam = params['DIAM']
    eratio = params['ERATIO']
    spi = params['SPI']

    # extracting uv coordinates and wavelength
    wavel = x[2]  # array of wavelength corresponding to each
    # measurement
    # u,v coordinates turned into angular frequencies
    u = x[0] / wavel
    v = x[1] / wavel
    waveref = x[3]  # Reference wavelength for spectral index
    # Now computing the spectral index corrected
    fluxw = flux * (waveref / wavel)**spi

    # Rotation in uv plane
    theta = -posang  # here the minus sine for compatibility with Aspro2
    ur = np.cos(theta) * u + np.sin(theta) * v
    vr = -np.sin(theta) * u + np.cos(theta) * v

    # Compression by elongation ratio
    uc = ur
    vc = eratio * vr
    bp = np.sqrt(uc**2 + vc**2)

    # Computation of offset factor
    voffset = np.exp(-2 * np.pi * 1j * (ofx * u + ofy * v))
    # visibility of uniform disk

    visibility = 2.0 * j1(np.pi * diam * bp ) / (np.pi * diam * bp)

    # final visibility and flux stored in dictionary
    visdat = {}
    visdat['VIS'] = fluxw * voffset * visibility
    visdat['FLUX'] = fluxw

    return visdat

def vis_point_source(x, params):
    '''vis_uniform_disk Computes the complex visibility and flux of a point source
    
    :param x: uv coordinates and wavelength
        x[0]: array of float (meters)
            U coordinates
        x[1]: array of float (meters)
            V coordinates
        x[2]: array of float (micron)
            Wavelength (same dim as X[0]
        x[3]: float (micron)
            Reference wavelength (for spectral index)
    :type x: 4D np.array

    :param params: Parameters describing the morphology
        params['FLUX'] : float
            total flux of the structure
        params['SPI'] : float
            spectral index (applied as (waveref/wave)**spi)
        params['OFX'] : float (radians)
            offset in the right ascension direction
        params['OFY'] : float (radians)
            offset in the declinaiton direction
    :type params: Dictionary

    :return: visdat dictionary
        visdat['VIS'] : complex visibility array of same dimension as
        the u,v coverage provided in the x array
        visdat['FLUX'] : spectral index corrected flux at each
        wavelength (same dim as VIS

    :Example:

    '''
    flux = params['FLUX']  # flux at reference wavelength wavel0
    ofx = params['OFX']
    ofy = params['OFY']
    spi = params['SPI']

    # extracting uv coordinates and wavelength
    wavel = x[2]  # array of wavelength corresponding to each
    # measurement
    # u,v coordinates turned into angular frequencies
    u = x[0] / wavel
    v = x[1] / wavel
    waveref = x[3]  # Reference wavelength for spectral index
    # Now computing the spectral index corrected
    fluxw = flux * (waveref / wavel)**spi

    # Computation of offset factor
    voffset = np.exp(-2 * np.pi * 1j * (ofx * u + ofy * v))

    # final visibility and flux stored in dictionary
    visdat = {}
    visdat['VIS'] = fluxw * voffset
    visdat['FLUX'] = fluxw

    return visdat


def vis_uniform_ring(x, params):
    '''vis_uniform_disk Computes the complex isibility and flux for a uniform disk.
    
    :param x: uv coordinates and wavelength
        x[0]: array of float (meters)
            U coordinates
        x[1]: array of float (meters)
            V coordinates
        x[2]: array of float (micron)
            Wavelength (same dim as X[0]
        x[3]: float (micron)
            Reference wavelength (for spectral index)
    :type x: 4D np.array

    :param params: Parameters describing the morphology
        params['POSANG'] : float (in radians)
            Position angle (north from east of ring major axis)
        params['FLUX'] : float
            total flux of the structure
        params['SPI'] : float
            spectral index (applied as (waveref/wave)**spi)
        params['OFX'] : float (radians)
            offset in the right ascension direction
        params['OFY'] : float (radians)
            offset in the declinaiton direction
        params['INDIAM'] : float (radians)
            Inner diameter of the ring.
        params['WIDTH'] : float (radians)
            Width of the ring
        params['ERATIO'] : float
            major/minor axis ratio (although will not mind if its the
            reverse (minor/major)
    :type params: Dictionary

    :return: visdat dictionary
        visdat['VIS'] : complex visibility array of same dimension as
        the u,v coverage provided in the x array
        visdat['FLUX'] : spectral index corrected flux at each
        wavelength (same dim as VIS

    :Example:

    '''    
    posang = params['POSANG']
    flux = params['FLUX']
    spi = params['SPI']
    ofx = params['OFX']
    ofy = params['OFY']
    indiam = params['INDIAM']
    width = params['WIDTH']
    eratio = params['ERATIO']

    # extracting uv coordinates and wavelength
    wavel = x[2]  # array of wavelength corresponding to each
    # measurement
    # u,v coordinates turned into angular frequencies
    u = x[0] / wavel
    v = x[1] / wavel
    waveref = x[3]  # Reference wavelength for spectral index
    # Now computing the spectral index corrected
    fluxw = flux * (waveref / wavel)**spi

    # Rotation in uv plane
    theta = -posang  # here the minus sine for compatibility with Aspro2
    ur = np.cos(theta) * u + np.sin(theta) * v
    vr = -np.sin(theta) * u + np.cos(theta) * v

    # Compression by elongation ratio
    uc = ur
    vc = eratio * vr
    bp = np.sqrt(uc**2 + vc**2)

    # Computation of offset factor
    voffset = np.exp(-2*np.pi * 1j * (ofx * u + ofy * v))

    # Compound visibility
    exdiam = indiam + 2 * width
    cnorm = 4 / (np.pi * (exdiam**2 - indiam**2))

    vis1 = indiam * j1(np.pi * indiam * bp) / (2 * bp)
    vis2 = exdiam * j1(np.pi * exdiam * bp) / (2 * bp)

    # Ring visibility
    visibility = cnorm * (vis2 - vis1)

    # final visibility and flux stored in dictionary
    visdat = {}
    visdat['VIS'] = fluxw * voffset * visibility
    visdat['FLUX'] = fluxw

    return visdat


def vis_modulated_ring(x, params):
    """
    visibility = vis_modulated_ring(x, params)

    Computes visibility curve for an azimutally modulated ring
    convolved with BL kernel and one modulation order.

    Parameters
    ----------

    params['POSANG'] : float (in radians)
        Position angle (north from east of ring major axis)
    params['FLUX'] : float
        total flux of the structure
    params['OFX'] : float (radians)
        offset in the right ascension direction
    params['OFY'] : float (radians)
        offset in the declinaiton direction
    params['RADIUS'] : float (radians)
        semi-major axis (radius) of the convolution kernel
    params['RINGRADIUS'] : float (radians)
        ring radius
    params['ERATIO'] : float
        major/minor axis ratio (although will not mind if
        its the reverse (minor/major)
    params['FLOR'] : float
        fraction of lorentzian vs gaussian in the convolution kernel
    params['MOD'] : float
        azimuthal modulation (should be an integer but not
        enforced). This gives the number of nodes along the
        ring. Warning do not set to 0 otherwise the visibility will
        not be normalized. To kill modulation just cet CM and SM to 0.
    params['CM'] : array (float) of dim MOD
        cosine amplitude of thxhse modulation
    params['SM'] : array (float) of dim MOD
        ine amplitude of the modulation

    Returns
    -------

    visibility: array of float
        complex visibility array of same dimension as the u,v coverage
        provided in the x array

    An example::
    # needs scipy.constants
    # loading file to provide uv coverage
    oifile = "Aspro2_HD_100546_PIONIER_1_533-1_772-6ch_A0-G1-J2-J1.fits"
    x, y, bp, wave = visutils.extract_uvcoverage(oifile)

    # providing parameters
    params = {}
    params['POSANG'] = 30.0 / 180. * np.pi
    params['FLUX'] = 1.0,
    params['OFX'] = 0.0 * constants.arcsecond / (1000)
    params['OFY'] = 0.0 * constants.arcsecond / (1000)
    params['RADIUS'] = 6.0 * constants.arcsecond / (1000)
    params['RINGRADIUS'] = 25.0 * constants.arcsecond / (1000)
    params['ERATIO'] = 0.3
    params['FLOR'] = 0.0
    params['MOD'] = 1.0
    params['CM'] = 0.0
    params['SM'] = 1.0

    # computing complex visibility and closure_phase
    vis = visfuncs.vis_sinusoidal_ring(x, params)
    cp = visfuncs.closure_phase(y, 'vis_sinusoidal_ring', params)
    """
    posang = params['POSANG']
#    flux = params['FLUX']
#    ofx = params['OFX']
#    ofy = params['OFY']
    ringradius = params['RINGRADIUS']
#    kernelradius = params['RADIUS']
    eratio = params['ERATIO']
#    flor = params['FLOR']
    mod = int(params['MOD'])  # this should be never fitted (noFit)
    cm = params['CM']  # cosine amplitude
    sm = params['SM']  # cosine amplitude

    # extracting uv coordinates and wavelength
    wavel = x[2]  # array of wavelength corresponding to each
    # measurement
    u = x[0] / wavel
    v = x[1] / wavel
    # Here we do not need to compute spectral index will be included
    # in the ellipsoid function

    # Rotation in uv plane
    theta = -posang  # here the minus sine for compatibility with Aspro2
    ur = np.cos(theta) * u + np.sin(theta) * v
    vr = -np.sin(theta) * u + np.cos(theta) * v

    # Compression by elongation ratio
    #uc = ur
    #vc = eratio * vr
    if eratio > 1:
        uc = ur/eratio
        vc = vr
    else:
        uc = ur*eratio
        vc = vr


    bp = np.sqrt(uc**2 + vc**2)
    psi = np.angle(uc + vc * 1.0j)

    # Computation of offset factor
    # voffset = np.exp(-2*np.pi * 1j * (ofx * u + ofy * v))
    # IMPORTANT xsnot needed here since voffset is already multplied in
    # the ellipsoid function - the flux is already included as well


    visarg = 2 * np.pi * bp * ringradius
    visring = j0(visarg)
    vismod = visring * 0.0
    for m in np.arange(mod):
    # modulation complex vector
        modvec = cm[m] + sm[m] * 1.0j
        rhomod = np.absolute(modvec)
        thetamod = np.angle(modvec)        
        vissin = (-1.0j)**(m + 1) * rhomod * np.cos((m + 1) * \
                                                    (psi - thetamod))\
                                                    * jv(m +1, visarg) 
        vismod = vismod + vissin
    vismodring = visring + vismod

    # computing kernel radius (convolution with kernel) and retrieving
    # the flux corrected from spectral index

    viskernel = vis_ellipsoid(x, params)['VIS']
    fluxkernel = vis_ellipsoid(x, params)['FLUX']

    # Combined visibility

    visibility = vismodring * viskernel

    visdat = {}
    visdat['VIS'] = visibility
    visdat['FLUX'] = fluxkernel

    return visdat


def vis_ellipsoid(x, params):
    """
    visdat = vis_ellipsoid(x, params)

    Computes visibility and flux for an ellipsoid the Lazareff way
    (i.e (1-flor) * Gaussian + flor * Lorentzian).


    Parameters
    ----------
    x[0]: array of float (meters)
        U coordinates
    x[1]: array of float (meters)
        V coordinates
    x[2]: array of float (micron)
        Wavelength (same dim as X[0]
    x[3]: float (micron)
        Reference wavelength (for spectral index)

    params['POSANG'] : float (in radians)
        Position angle (north from east of ring major axis)
    params['FLUX'] : float
        total flux of the structure
    params['SPI'] : float
        spectral index (applied as (waveref/wave)**spi)
    params['OFX'] : float (radians)
        offset in the right ascension direction
    params['OFY'] : float (radians)
        offset in the declinaiton direction
    params['RADIUS'] : float (radians)
        semi-major axis (radius) of the convolution kernel
    params['ERATIO'] : float
        major/minor axis ratio (although will not mind if
        its the reverse (minor/major)
    params['FLOR'] : float
        fraction of lorentzian vs gaussian in the convolution kernel

    Returns
    -------

    visdat: dictionary
        visdat['VIS'] : complex visibility array of same dimension as
        the u,v coverage provided in the x array
        visdat['FLUX'] : spectral index corrected flux at each
        wavelength (same dim as VIS

    An example:: # TODO: update example
    # needs scipy.constants
    # loading file to provide uv coverage
    oifile = "Aspro2_HD_100546_PIONIER_1_533-1_772-6ch_A0-G1-J2-J1.fits"
    x, y, bp, wave = visutils.extract_uvcoverage(oifile)

    # providing parameters
    params['MOD'] = 1.0
    params['CM'] = 0.0
    params['SM'] = 1.0

    # computing complex visibility and closure_phase
    vis = visfuncs.vis_sinusoidal_ring(x, params)
    cp = visfuncs.closure_phase(y, 'vis_sinusoidal_ring', params)
    """
    posang = params['POSANG']
    flux = params['FLUX']
    ofx = params['OFX']
    ofy = params['OFY']
    radius = params['RADIUS']
    eratio = params['ERATIO']
    flor = params['FLOR']
    spi = params['SPI']

    # extracting uv coordinates and wavelength
    wavel = x[2]  # array of wavelength corresponding to each
    # measurement
    u = x[0] / wavel
    v = x[1] / wavel
    waveref = x[3]  # Reference wavelength for spectral index
    # Now computing the spectral index corrected
    fluxw = flux * (waveref / wavel)**spi

    # Rotation in uv plane
    theta = -posang  # here the minus sine for compatibility with Aspro2
    ur = np.cos(theta) * u + np.sin(theta) * v
    vr = -np.sin(theta) * u + np.cos(theta) * v

    # Compression by elongation ratio
    # uc = ur
    # vc = eratio * vr
    if eratio > 1:
        uc = ur/eratio
        vc = vr
    else:
        uc = ur*eratio
        vc = vr

    bp = np.sqrt(uc**2 + vc**2)

    # Computation of offset factor
    voffset = np.exp(-2*np.pi * 1j * (ofx * u + ofy * v))

    # Gaussian and Lorentzian visibility  then combination weighed by
    # flor
    alpha = radius / np.sqrt(3)
    vislor = np.exp(-2 * np.pi * alpha * bp)
    visgauss = np.exp(-np.pi**2 / np.log(2) * radius**2 * bp**2)

    viscombine = flor * vislor + (1 - flor) * visgauss

    # final visibility and flux stored in dictionary
    visdat = {}
    visdat['VIS'] = fluxw * voffset * viscombine
    visdat['FLUX'] = fluxw

    return visdat


def vis_gaussian(x, params):
    """ Computing visibility of gaussian


    USAGE: vis = vis_gaussian(x, params)

    WARNING: returns a complex number

    :param x:
    :param params:
    :return:
    """
    flux = params['FLUX']
    ofx = params['OFX']
    ofy = params['OFY']
    posang = params['POSANG']
    fwhm = params['FWHM']
    eratio = params['ERATIO']
    spi = params['SPI']

    # extracting uv coordinates and wavelength
    wavel = x[2]  # array of wavelength corresponding to each
    # measurement
    u = x[0] / wavel
    v = x[1] / wavel
    waveref = x[3]  # Reference wavelength for spectral index
    # Now computing the spectral index corrected
    fluxw = flux * (waveref / wavel)**spi

    # Rotation in uv plane
    theta = -posang  # here the minus sine for compatibility with Aspro2
    ur = np.cos(theta) * u + np.sin(theta) * v
    vr = -np.sin(theta) * u + np.cos(theta) * v

    # Compression by elongation ratio
    uc = ur
    vc = eratio * vr
    bp = np.sqrt(uc**2 + vc**2)

    # Computation of offset factor
    voffset = np.exp(-2 * np.pi * 1j * (ofx * u + ofy * v))

    # final visibility

    visgauss = np.exp(-np.pi**2 * fwhm**2 * bp**2 / np.log(2))

    # final visibility and flux stored in dictionary
    visdat = {}
    visdat['VIS'] = fluxw * voffset * visgauss
    visdat['FLUX'] = fluxw

    return visdat