import numpy as np
from scipy.special import j0, j1, jv
import sys
thismod = sys.modules[__name__]
import logging
#
# logging configuration
#
LOGLEVEL = "INFO"
logger = logging.getLogger(__name__)
logger.setLevel(LOGLEVEL)



"""
collection of functions parametrized by dictionnaries, to allow easy fitting
of visibility functions with visfit module

The main difference with visfuncs is the introduction of the spectral
index which required major modifications.

author: Jean-Philippe.Berger@univ-grenoble-alpes.fr

"""

# TODO: include examples 
# TODO: verify documentation
# TODO: mofify comments
# TODO: add type in combine_functions visdat to keep memory of the functiosn
# combined
# TODO: include a verification with Aspro2 of all rings

def combine_functions(x, params):
    """Allows to call any combination of function defined inside visfuncs to create an object and compute visibility and flux

    visdat = vis_combine_functions(x, params)

    params={'funcA;1:p1':, 'funcA;1:p2':, 'funcA;2:p1':, 'funcA;2:p2':, 'funcB:p1':, etc}
    funcA and funcB should be defined in visfuncs.py. Allows to call
    many instances of the same function (here funcA) and combine
    different functions.  Outputs of the difference functions will be
    sumed usinf operator '+'.

    Parameters
    ----------
    x : np.array

            x[0]: u coordinate array

            x[1]: v coordinate array

            x[2]: effective wavelength coordinate

            x[3]: reference wavelength

    params : dictionary
            'funcA;1:p1': .., 'funcA;1:p2':.., 'funcA;2:p1':, 'funcA;2:p2':, 'funcB:p1':, etc}

    Returns
    -------
    visdat : dictionary
        visdat['VIS']  flux weighted complex visibility  for each uv point

        visdat['FLUX'] flux for each uv point

    Examples
    --------

        >>> visdat = vis_combine_functions(x, params)

    """

    # -- list of functions:
    funcs = set([k.strip().split(':')[0].strip() for k in params.keys()])
    vis = 0
    flux = 0
    totalflux = 0
    for f in funcs:  # for each function
        # -- keep only relevant keywords
        kz = filter(lambda k: k.strip().split(':')[0].strip() == f,
                    params.keys())
        tmp = {}
        for k in kz:
            # -- build temporary dict pf parameters
            paramname = k.split(':')[1].strip()
            if paramname == 'FLUX':
                totalflux += params[k]
            tmp[k.split(':')[1].strip()] = params[k]
        ff = f.split(';')[0].strip()  # actual function name
        print("Found function {0}".format(ff))
        #        if not fitfuncs.__dict__.has_key(ff):
        #        if not thismod.__dict__.has_key(ff):
        # python 3 way
        if ff not in thismod.__dict__:
            raise NameError(ff + ' not defined in fitfuncs')
        # -- add to result the function result
        vis += thismod.__dict__[ff](x, tmp)['VIS']
        flux += thismod.__dict__[ff](x, tmp)['FLUX']
        #        res += fitfuncs.__dict__[ff](x, tmp)
    visdat = {}
    visdat['VIS'] = vis / flux
    visdat['FLUX'] = flux

    return visdat

def compute_closure_phase(y, fitfunc, params):
    """

    :param y:
    :param function:
    :param fitfunc:
    :param params:
    :param module:
    :return:
    """

    # Extracting u and v for the 3 baselines
    x1 = np.array([y[0], y[1], y[4], y[5]])
    x2 = np.array([y[2], y[3], y[4], y[5]])
    x3 = np.array([-y[0] - y[2], -y[1] - y[3], y[4], y[5]])

    visfunc = getattr(thismod, fitfunc)
    vis1 = visfunc(x1, params)['VIS']
    vis2 = visfunc(x2, params)['VIS']
    vis3 = visfunc(x3, params)['VIS']

    bispectrum = vis1 * vis2 * vis3

    return np.arctan2(np.imag(bispectrum), np.real(bispectrum)) / np.pi * 180.0

def vis_uniform_disk(x, params):
    '''vis_uniform_disk Computes the complex isibility and flux for a uniform disk.
    
    :param x: uv coordinates and wavelength
        x[0]: array of float (meters)
            U coordinates
        x[1]: array of float (meters)
            V coordinates
        x[2]: array of float (micron)
            Wavelength (same dim as X[0]
        x[3]: float (micron)
            Reference wavelength (for spectral index)
    :type x: 4D np.array

    :param params: Parameters describing the morphology
        params['POSANG'] : float (in radians)
            Position angle (north from east of ring major axis)
        params['FLUX'] : float
            total flux of the structure
        params['SPI'] : float
            spectral index (applied as (waveref/wave)**spi)
        params['OFX'] : float (radians)
            offset in the right ascension direction
        params['OFY'] : float (radians)
            offset in the declinaiton direction
        params['DIAM'] : float (radians)
            Diameter of the uniform disk.
        params['ERATIO'] : float
            major/minor axis ratio (although will not mind if its the
            reverse (minor/major)
    :type params: Dictionary

    :return: visdat dictionary
        visdat['VIS'] : complex visibility array of same dimension as
        the u,v coverage provided in the x array
        visdat['FLUX'] : spectral index corrected flux at each
        wavelength (same dim as VIS

    :Example:

    '''
    flux = params['FLUX']
    ofx = params['OFX']
    ofy = params['OFY']
    posang = params['POSANG']
    diam = params['DIAM']
    eratio = params['ERATIO']
    spi = params['SPI']

    # extracting uv coordinates and wavelength
    wavel = x[2]  # array of wavelength corresponding to each
    # measurement
    # u,v coordinates turned into angular frequencies
    u = x[0] / wavel
    v = x[1] / wavel
    waveref = x[3]  # Reference wavelength for spectral index
    # Now computing the spectral index corrected
    fluxw = flux * (waveref / wavel)**spi

    # Rotation in uv plane
    theta = -posang  # here the minus sine for compatibility with Aspro2
    ur = np.cos(theta) * u + np.sin(theta) * v
    vr = -np.sin(theta) * u + np.cos(theta) * v

    # Compression by elongation ratio
    uc = ur
    vc = eratio * vr
    bp = np.sqrt(uc**2 + vc**2)

    # Computation of offset factor
    voffset = np.exp(-2 * np.pi * 1j * (ofx * u + ofy * v))
    # visibility of uniform disk

    visibility = 2.0 * j1(np.pi * diam * bp ) / (np.pi * diam * bp)

    # final visibility and flux stored in dictionary
    visdat = {}
    visdat['VIS'] = fluxw * voffset * visibility
    visdat['FLUX'] = fluxw

    return visdat

def vis_point_source(x, params):
    '''vis_uniform_disk Computes the complex visibility and flux of a point source
    
    :param x: uv coordinates and wavelength
        x[0]: array of float (meters)
            U coordinates
        x[1]: array of float (meters)
            V coordinates
        x[2]: array of float (micron)
            Wavelength (same dim as X[0]
        x[3]: float (micron)
            Reference wavelength (for spectral index)
    :type x: 4D np.array

    :param params: Parameters describing the morphology
        params['FLUX'] : float
            total flux of the structure
        params['SPI'] : float
            spectral index (applied as (waveref/wave)**spi)
        params['OFX'] : float (radians)
            offset in the right ascension direction
        params['OFY'] : float (radians)
            offset in the declinaiton direction
    :type params: Dictionary

    :return: visdat dictionary
        visdat['VIS'] : complex visibility array of same dimension as
        the u,v coverage provided in the x array
        visdat['FLUX'] : spectral index corrected flux at each
        wavelength (same dim as VIS

    :Example:

    '''
    flux = params['FLUX']  # flux at reference wavelength wavel0
    ofx = params['OFX']
    ofy = params['OFY']
    spi = params['SPI']

    # extracting uv coordinates and wavelength
    wavel = x[2]  # array of wavelength corresponding to each
    # measurement
    # u,v coordinates turned into angular frequencies
    u = x[0] / wavel
    v = x[1] / wavel
    waveref = x[3]  # Reference wavelength for spectral index
    # Now computing the spectral index corrected
    fluxw = flux * (waveref / wavel)**spi

    # Computation of offset factor
    voffset = np.exp(-2 * np.pi * 1j * (ofx * u + ofy * v))

    # final visibility and flux stored in dictionary
    visdat = {}
    visdat['VIS'] = fluxw * voffset
    visdat['FLUX'] = fluxw

    return visdat


def vis_uniform_ring(x, params):
    '''vis_uniform_disk Computes the complex isibility and flux for a uniform disk.
    
    :param x: uv coordinates and wavelength
        x[0]: array of float (meters)
            U coordinates
        x[1]: array of float (meters)
            V coordinates
        x[2]: array of float (micron)
            Wavelength (same dim as X[0]
        x[3]: float (micron)
            Reference wavelength (for spectral index)
    :type x: 4D np.array

    :param params: Parameters describing the morphology
        params['POSANG'] : float (in radians)
            Position angle (north from east of ring major axis)
        params['FLUX'] : float
            total flux of the structure
        params['SPI'] : float
            spectral index (applied as (waveref/wave)**spi)
        params['OFX'] : float (radians)
            offset in the right ascension direction
        params['OFY'] : float (radians)
            offset in the declinaiton direction
        params['INDIAM'] : float (radians)
            Inner diameter of the ring.
        params['WIDTH'] : float (radians)
            Width of the ring
        params['ERATIO'] : float
            major/minor axis ratio (although will not mind if its the
            reverse (minor/major)
    :type params: Dictionary

    :return: visdat dictionary
        visdat['VIS'] : complex visibility array of same dimension as
        the u,v coverage provided in the x array
        visdat['FLUX'] : spectral index corrected flux at each
        wavelength (same dim as VIS

    :Example:

    '''    
    posang = params['POSANG']
    flux = params['FLUX']
    spi = params['SPI']
    ofx = params['OFX']
    ofy = params['OFY']
    indiam = params['INDIAM']
    width = params['WIDTH']
    eratio = params['ERATIO']

    # extracting uv coordinates and wavelength
    wavel = x[2]  # array of wavelength corresponding to each
    # measurement
    # u,v coordinates turned into angular frequencies
    u = x[0] / wavel
    v = x[1] / wavel
    waveref = x[3]  # Reference wavelength for spectral index
    # Now computing the spectral index corrected
    fluxw = flux * (waveref / wavel)**spi

    # Rotation in uv plane
    theta = -posang  # here the minus sine for compatibility with Aspro2
    ur = np.cos(theta) * u + np.sin(theta) * v
    vr = -np.sin(theta) * u + np.cos(theta) * v

    # Compression by elongation ratio
    uc = ur
    vc = eratio * vr
    bp = np.sqrt(uc**2 + vc**2)

    # Computation of offset factor
    voffset = np.exp(-2*np.pi * 1j * (ofx * u + ofy * v))

    # Compound visibility
    exdiam = indiam + 2 * width
    cnorm = 4 / (np.pi * (exdiam**2 - indiam**2))

    vis1 = indiam * j1(np.pi * indiam * bp) / (2 * bp)
    vis2 = exdiam * j1(np.pi * exdiam * bp) / (2 * bp)

    # Ring visibility
    visibility = cnorm * (vis2 - vis1)

    # final visibility and flux stored in dictionary
    visdat = {}
    visdat['VIS'] = fluxw * voffset * visibility
    visdat['FLUX'] = fluxw

    return visdat
