import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cm as cm
from astropy.io import fits as pif
import matplotlib.colors as colors
import os
import glob as glob
import logging
import sys
import time

# TODO: include proper way to handle the cases when there are missing baselines and one telescope ignored
# TODO: change name of oidata in oiblocks
# TODO: create dedicated class for plotting and oidata manipulation
# TODO: better management of files where one baseline in missing
# recall logging levels DEBUG, INFO, WARNING, ERROR, CRITICAL

class Oifits:

    def __init__(self, filelist = [], loglevel="INFO"):
        self.__version__ = "0.9"
        self.logger = logging.getLogger(__name__)
        self.logger.setLevel(loglevel)
        self.timecreated = time.asctime()
        self.filelist = filelist
        self.load_filelist(filelist)
        if filelist != []: #option to create empty Oifits object
            self.get_cpdata()
            self.get_v2data()
        

    def load_filelist(self, filelist):
        """
        load_fileist(filelist)

        Loads fits filelist and turns it into oidata format
        """
        oidatamerge = []
        for file in filelist:
            self.logger.info("Loading file {0}".format(file))
            oidataloc = self._loadfile(file)
            oidatamerge = oidataloc + oidatamerge
        self.oidata = oidatamerge
        self.lastupdate = time.asctime()

    def append_filelist(self, filelist):
        """
        append_filelist(filelist):

        Adds a file list fits file data to the current oidata
        """
        oidatamerge = self.oidata
        for file in filelist:
            self.logger.info("Adding file {0}".format(file))
            oidataloc = self._loadfile(file)
            oidatamerge = oidataloc + oidatamerge
        self.filelist = self.filelist + filelist
        self.oidata = oidatamerge
        self.get_cpdata()
        self.get_v2data()
        self.lastupdate = time.asctime()

    def _loadfile(self, filename):
        """
        _loadfile(filename):

        Private function.
        Returns a list of all observing blocks contained in oidata class.
        Tuned for PIONIER oifits
        """
        self.filename = filename
        self.updated = time.asctime()
        hdulist = pif.open(filename)
        oiwavelength = {}
        measure = []
        # Extracting average seeing and coherence time
        seeing, tau0, windspeed = self._extract_weather_conditions(hdulist[0])
        # Name of the instrument
        # NB: Aspro2 does not generates instrument name in its main header
        # hence the try test below
        try:
            hdulist[0].header['INSTRUME']
            instrument = hdulist[0].header['INSTRUME']
        except:
            self.logger.info("No INSTRUMENT name found in main header")
        for hdu in hdulist[1:]:
                if hdu.header['EXTNAME'] == 'OI_TARGET':
                    data = hdu.data
                    datacontent = [[dat['TARGET'], dat['RAEP0'],
                                    dat['DECEP0'], dat['EQUINOX']] for dat
                                   in data]
                    oitarget = dict(zip(data['TARGET_ID'], datacontent))
                    numtarget = len(datacontent)
                elif hdu.header['EXTNAME'] == 'OI_ARRAY':
                    data = hdu.data
                    datacontent = [[dat['TEL_NAME'], dat['STA_NAME'],
                                    dat['DIAMETER']] for dat in data]
                    oiarray = dict(zip(data['STA_INDEX'], datacontent))
                elif hdu.header['EXTNAME'] == 'OI_WAVELENGTH':
                    data = hdu.data
                    datacontent = [data[name] for name in data.names]
                    oiwavelength[hdu.header['INSNAME']] = datacontent
                elif hdu.header['EXTNAME'] == 'OI_VIS2':
                    nmeasurement = hdu.header['NAXIS2'] # number of measurements (columns)
                    d = hdu.data
                    insname = hdu.header['INSNAME']
                    arrname = hdu.header['ARRNAME']
                    dateobs = hdu.header['DATE-OBS']
                    wavel = oiwavelength[insname]
                    v2 = d['VIS2DATA']
                    ev2 = d['VIS2ERR']
                    u = d['UCOORD']
                    v = d['VCOORD']
                    bp = np.sqrt(u ** 2 + v ** 2)
                    dit = d['INT_TIME']
                    for i, mjd in enumerate(d['MJD']):
                        target = oitarget[d['TARGET_ID'][i]][0]
                        tel1 = oiarray[d['STA_INDEX'][i][0]][1]
                        tel2 = oiarray[d['STA_INDEX'][i][1]][1]
                        for j, wave in enumerate(wavel[0]):
                            meas = {}
                            meas['FWHM'] = seeing # arcseconds
                            meas['TAU0'] = tau0 #milliseconds
                            meas['WINDSP'] = windspeed # m/s
                            meas['NMEAS'] = nmeasurement # number of measurements
                            meas['TARGET'] = target
                            meas['TYPE'] = "V2"
                            meas['MJD'] = mjd
                            meas['DIT'] = dit[i]
                            meas['WAVE_TABLE'] = wavel[0] # includes wavelength table from OI_WAVELENGTH
                            meas['EFF_WAVE'] = wave
                            meas['EFF_BAND'] = wavel[1][j]
                            meas['TEL1'] = tel1
                            meas['TEL2'] = tel2
                            meas['CONFIG'] = tel1 + tel2
                            meas['UCOORD'] = u[i]
                            meas['VCOORD'] = v[i]
                            if (u[i] != 0):
                                meas['THETA'] = np.arctan(v[i] / u[i]) * 180 / np.pi
                            else: 
                                # if some telescope are ignored (VLTI) the oifits will still contain data at 
                                #baselines where theres is no measurements but with - values
                                self.logger.warning("Some U coordinates = 0 . Missing Baselines ? THETA set to 512 degrees")
                                meas['THETA'] = 512
                            meas['BP'] = bp[i]
                            meas['ARRNAME'] = arrname
                            meas['INSNAME'] = insname
                            meas['DATE-OBS'] = dateobs
                            try:
                                meas['VIS2DATA'] = v2[i, j]
                                meas['VIS2ERR'] = 0.02#ev2[i, j]
                            except:
                                meas['VIS2DATA'] = v2[i]
                                meas['VIS2ERR'] = 0.02#ev2[i]
                            measure.append(meas)
                elif hdu.header['EXTNAME'] == 'OI_T3':
                    nmeasurement = hdu.header['NAXIS2'] # number of measurements  (columns)
                    d = hdu.data
                    insname = hdu.header['INSNAME']
                    wavel = oiwavelength[insname]
                    t3amp = d['T3AMP']
                    t3amperr = d['T3AMPERR']
                    t3phi = d['T3PHI']
                    t3phierr = d['T3PHIERR']
                    insname = hdu.header['INSNAME']
                    arrname = hdu.header['ARRNAME']
                    dateobs = hdu.header['DATE-OBS']
                    u1 = d['U1COORD']
                    v1 = d['V1COORD']
                    u2 = d['U2COORD']
                    v2 = d['V2COORD']
                    b1 = np.sqrt(u1 ** 2 + v1 ** 2)
                    b2 = np.sqrt(u2 ** 2 + v2 ** 2)
                    b3 = np.sqrt((u2 + u1) ** 2 + (v2 + v1) ** 2)
                    dit = d['INT_TIME']
                    for i, mjd in enumerate(d['MJD']):
                        target = oitarget[d['TARGET_ID'][i]][0]
                        tel1 = oiarray[d['STA_INDEX'][i][0]][1]
                        tel2 = oiarray[d['STA_INDEX'][i][1]][1]
                        tel3 = oiarray[d['STA_INDEX'][i][2]][1]
                        for j, wave in enumerate(wavel[0]):
                            meas = {}
                            meas['FWHM'] = seeing # arcseconds
                            meas['TAU0'] = tau0 # milliseconds
                            meas['WINDSP'] = windspeed #m/s
                            meas['NMEAS'] = nmeasurement
                            meas['TARGET'] = target
                            meas['TYPE'] = 'T3'
                            meas['MJD'] = mjd
                            meas['DIT'] = dit[i]
                            meas['WAVE_TABLE'] = np.array(wavel[0])
                            meas['EFF_WAVE'] = wave
                            meas['EFF_BAND'] = wavel[1][j]
                            meas['TEL1'] = tel1
                            meas['TEL2'] = tel2
                            meas['TEL3'] = tel3
                            meas['CONFIG'] = tel1 + tel2 + tel3
                            meas["U1COORD"] = u1[i]
                            meas["V1COORD"] = v1[i]
                            meas["U2COORD"] = u2[i]
                            meas["V2COORD"] = v2[i]
                            meas['ARRNAME'] = arrname
                            meas['INSNAME'] = insname
                            meas['DATE-OBS'] = dateobs
                            try:
                                meas["T3AMP"] = t3amp[i, j]
                                meas["T3AMPERR"] = 1#t3amperr[i, j]
                            except:
                                meas["T3AMP"] = t3amp[i]
                                meas["T3AMPERR"] = 1#t3amperr[i]
                            meas["BP1"] = b1[i]
                            meas["BP2"] = b2[i]
                            meas["BP3"] = b3[i]
                            meas['BMAX'] = max(b1[i], b2[i], b3[i])
                            meas['BGEO'] = (b1[i] * b2[i] * b3[i]) ** (1. / 3)
                            try:
                                meas["T3PHI"] = t3phi[i, j]
                                meas["T3PHIERR"] = t3phierr[i, j]
                            except:
                                meas["T3PHI"] = t3phi[i]
                                meas["T3PHIERR"] = t3phierr[i]
                            measure.append(meas)
                            #    print "Found {} targets in oifits data".format(numtarget)
        logging.info("Found {} targets in oifits data".format(numtarget))
        #    for i in np.arange(numtarget): created bugs when ID not in order
        for i in oitarget.keys():
            logging.info(oitarget[i][0])
        if numtarget >= 2:
            logging.info("Remember to separate them from the oidata")
        oidata = measure
        return oidata


    def get_cpdata(self):
        """
        get_cpdatanew(self)
        """
        try:
            t3data = list(filter(lambda x: x['TYPE'] == 'T3', self.oidata))
           
        except:
            logging.ERROR("There is no T3 data in this file")
            raise
        cpdata = {key:"" for key in t3data[0].keys() if key != 'WAVE_TABLE'}
        for key in t3data[0].keys(): ### Fails for gravity because 2 instruments have 2 different wavetable lengths
            if key != 'WAVE_TABLE': ###Added filter - BA
                cpdata[key] = np.array([cp[key] for cp in t3data])
        # max baseline of triangle
        #mjd = np.array([t3['MJD'] for t3 in t3data])
        bpmax = np.array([max(t3['BP1'], t3['BP2'], t3['BP3'])
                          for t3 in t3data])
        # geometrical mean
        bpgeom = np.array([(t3['BP1'] * t3['BP2'] * t3['BP3'])**(1. /3.) for t3
                          in t3data])
        cpdata['BPMAX'] = bpmax
        cpdata['BPGEOM'] = bpgeom
        self.cpdata = cpdata


    def get_v2data(self):
        '''
        oi_get_v2data() 

        Extracts V2data from oidata
        '''
        try:
            vis2data = list(filter(lambda x: x['TYPE'] == 'V2', self.oidata))
        except:
            logging.ERROR("There is no V2 data in this file")
            raise
        v2data = {key:"" for key in vis2data[0].keys() if key != 'WAVE_TABLE'}
        for key in vis2data[0].keys(): ###Idem
            if key != 'WAVE_TABLE': ###Idem
                v2data[key] = np.array([v2[key] for v2 in vis2data])
        self.v2data = v2data


    def filter_oidata(self, filtertype, filterparam):
        """

        Parameters
        ----------
        filtertype : string
            "wave_equal" keeps only wave data with wavelength = filterparam[0]

        filterparam : list
            "wave_equal" filterparam[0] = wavelength (microns)

        Returns
        -------
        filtereddata : filtered oidata

        # TODO: in reality should return v2data and cpdata directly
        """
        filterlist = ["wave_equal"]
        if filtertype not in filterlist:
            self.logger.warning("There is no filter {0} available".format(filtertype))
            self.logger.info("Available filters {0}".format(filterlist))
        if filtertype == "wave_equal":
            self.logger.info("Filtering by wavelength {:10.4e}".format(filterparam[0]))
            filtereddata = [oi for oi in self.oidata if oi['EFF_WAVE'] == filterparam[0]]
        else:
            filtereddata = []
        if not filtereddata:
            self.logger.warning("No data corresponds to this filter")
            filtereddata = []
        return filtereddata

    def plot_uvcov(self, type='polar', base='freq',
                   window=1, subplot=111, oplot=1, scale=1):
        """

        """
        plt.figure(window)
        if oplot == 0:
            plt.clf()
        v2m = list(filter(lambda x: x['TYPE'] == 'V2', self.oidata))
        based = {'meter': 'm', 'freq': '$M\lambda$'}
        ucoord = np.array([x['UCOORD'] for x in v2m])
        vcoord = np.array([x['VCOORD'] for x in v2m])
        wavel = np.array([x['EFF_WAVE'] for x in v2m])
        if (base == 'freq'):
            norm = wavel
        if (base == 'meter'):
            norm = wavel / wavel
        if (type == 'polar'):
            axuv = plt.subplot(subplot, polar=True)
            axuv.set_thetagrids(np.array([0, 30, 45, 60, 90, 120, 135,
                        150, 180, 210, 225, 240, 270, 300, 315, 330])[::-1])
            axuv.set_theta_zero_location('N')
            axuv.set_theta_direction(-1)
            axuv.set_theta_offset(np.pi / 2)
            theta = np.arctan(ucoord / vcoord)
            r = np.sqrt(ucoord ** 2 + vcoord ** 2) * 1e-6
            the = np.hstack((theta, theta + np.pi))
            rad = np.hstack((r / norm, r / norm))
            axuv.plot(the, rad, '.', lw=3, alpha=0.5)
            axuv.text(np.pi / 2.1, max(rad) * 0.8, 'U (' + based[base] + ')')
            axuv.text(-np.pi / 20, max(rad) * 0.9, 'V (' + based[base] + ')')
            axuv.set_title('UV coverage')
        if (type == 'square'):
            axuv = plt.subplot(subplot)
            u = np.hstack((ucoord / norm, -ucoord / norm))
            v = np.hstack((vcoord / norm, -vcoord / norm))
            axuv.plot(u, v, 'o', lw=3, alpha=0.5)
            axuv.set_xlabel('U (' + based[base] + ')')
            axuv.set_ylabel('V (' + based[base] + ')')
            if (scale):
                limit = max(np.sqrt((u ** 2 + v ** 2)))
                axuv.set_ylim(-limit * 1.4, limit * 1.4)
                axuv.set_xlim(-limit * 1.4, limit * 1.4)
                axuv.set_aspect(1.0)
            axuv.grid(True)
            #axuv.set_title(oidata[0]['TARGET'] + ' ' + addleg) #undefined var oidata, addleg - BA
        

    def _extract_weather_conditions(self, hdu):
        '''
        seeing, tau0, windspeed = _extract_weather_conditions(self, hdu)
        '''
        try: 
            hdu.header['ORIGIN']
            if hdu.header['ORIGIN'][0:3] == 'ESO':
                try:
                    self.logger.warning("Found ESO ISS weather information")
                    fwhme= hdu.header['HIERARCH ESO ISS AMBI FWHM END']
                    fwhms= hdu.header['HIERARCH ESO ISS AMBI FWHM START']
                    seeing = (fwhme + fwhms) / 2
                    tau0e= hdu.header['HIERARCH ESO ISS AMBI TAU0 END']
                    tau0s= hdu.header['HIERARCH ESO ISS AMBI TAU0 START']
                    tau0 = (tau0s + tau0e) / 2
                    windspeed = hdu.header['HIERARCH ESO ISS AMBI WINDSP']
                except:
                    self.logger.warning("No ESO ISS weather information")
                    seeing = tau0 = windspeed = 0.0
            else:
                self.logger.warning('Non ESO instrument. No weather information')
                seeing = tau0 = windspeed = 0.0
            return seeing, tau0, windspeed
        except:
            self.logger.info("No ORIGIN name found in main header")
            return 0, 0, 0

