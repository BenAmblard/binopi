import numpy as np
import logging
import sys

# logging configuration
LOGLEVEL = "WARNING"
logger = logging.getLogger(__name__)
logger.setLevel(LOGLEVEL)


def filter_by_wavelength(oiblocks, wavelength, loglevel = LOGLEVEL):
    """
    filter_by_wavelength(oiblocks, wavelength)
    """
    logger.setLevel(loglevel)
    logger.info("Filtering by wavelength {:10.4e}".format(wavelength))
    filtereddata = [oi for oi in oiblocks if oi['EFF_WAVE'] == wavelength]
    return filtereddata

def filter_by_keyword(oiblocks, keyword, value, loglevel = LOGLEVEL):
    """
    filter_by_keyword(oiblocks, keyword, value)
    """
    logger.setLevel(loglevel)
    logger.info("Filtering by keyword {0} = {1}".format(keyword, value))
    filtereddata = [oi for oi in oiblocks if oi[keyword] == value]
    return filtereddata

def filter_by_keyword_range(oiblocks, keyword, range, loglevel = LOGLEVEL):
    """
    filter_by_keyword_range(oiblocks, keyword, range)
    """
    logger.info("WARNING: make sur that keyword is present in blocks (e.g V2 vs Tc) ")
    logger.setLevel(loglevel)
    logger.info("Filtering by keyword range {0} = {1}".format(keyword, range))
    filtereddata = [oi for oi in oiblocks 
        if ((oi[keyword] >= range[0])& (oi[keyword] <= range[1]))]
    return filtereddata


def filter_by_date(oiblocks, date, loglevel = LOGLEVEL):
    '''filter_by_date filters oiblocks by observing date

    Date can be only year: "2020" of year + month: "2020-04" etc.

    :param oiblocks: oifits data blocks
    :type oiblocks: array of dict
    :param date: obserging date date in format YYYY-MM-DD
    :type date: string
    '''
    logger.info("Filtering by date {0} = {1}".format("DATE-OBS", date))
    filtereddata = [oi for oi in oiblocks if oi["DATE-OBS"][0:len(date)] == date]
    return filtereddata


def filter_by_zone(oiblocks, keywords, range, loglevel = LOGLEVEL ):
    '''filter_by_zone filters by ranges in 2D (for example cone search in uv plane)

    WARNING: for "THETA" keyword angles make sure you have the correct signs

    :param oiblocks: oidata blocks
    :type oiblocks: array of dict
    :param keywords: two oidata keywords to be explored
    :type keywords: array of strings 
    :param range: min and max values for each keyword
    :type range: [[minkw1,maxkw1],[minkw1,maxkw2]]
    :param loglevel: degree of verbosity, defaults to LOGLEVEL
    :type loglevel: string, optional
    :return: oiblocks
    :rtype: list
    '''
    logger.setLevel(loglevel)
    logger.info("WARNING: make sur that keyword is present in blocks (e.g V2 vs Tc) ")
    logger.info("Filtering by zone range {0} = {1}".format(keywords, range))
    filtereddata = [oi for oi in oiblocks 
        if (((oi[keywords[0]] >= range[0][0])& (oi[keywords[0]] <= range[0][1]))
        &((oi[keywords[1]] >= range[1][0])& (oi[keywords[1]] <= range[1][1])))]
    return filtereddata

def average_by_mjd(oiblocks, loglevel = LOGLEVEL):
    """
    average_by_mjd 
    
    
    [description]
    
    :param oiblocks: [description]
    :type oiblocks: [type]
    :param loglevel: [description], defaults to LOGLEVEL
    :param loglevel: [type], optional
    """
    umjd = np.unique([oi['MJD'] for oi in oiblocks])
    oiallavg = []
    oiv2avg = []
    oit3avg = []
    # FIXME: intrinsically weak because considers V2 and T3 present in data
    for mjd in umjd:
        # selecting all points with same mjd
        oimjd = [oi for oi in oiblocks if oi['MJD']==mjd]
        oitypes = np.unique([oi['TYPE'] for oi in oiblocks])
        if ('V2' in oitypes):
            # averaging squared visibilities and error
            v2data = get_v2data(oimjd)
            avgvis2data = np.average(v2data['VIS2DATA'])
            avgvis2err = np.average(v2data['VIS2ERR'])
            # creating a new averaged V2 oiblock
            oiv2i = oimjd[0]
            oiv2i['VIS2DATA'] = avgvis2data
            oiv2i['VIS2ERR'] = avgvis2err
            oiv2avg = oiv2avg + [oiv2i]
        if ('T3' in oitypes):
            # averaging closure phase data
            t3data = get_cpdata(oimjd)
            avgt3phi = np.average(t3data['T3PHI'])
            avgt3phierr = np.average(t3data['T3PHIERR'])
            #creating a new averaged V2 oiblock
            oit3i = oimjd[-1]
            oit3i['T3PHI'] = avgt3phi
            oit3i['T3PHIERR'] = avgt3phierr
            oit3avg = oit3avg + [oit3i]
    oiallavg = oiv2avg + oit3avg
    return oiallavg



def sort_by_configuration(oiblocks, loglevel = LOGLEVEL):
    """
    sort_by_configuration(oiblocks):  
    """
    logger.setLevel(loglevel)
    configs = np.unique([oi['CONFIG'] for oi in oiblocks])
    oiallconfsv2 = []
    oiallconfst3 = []
    v2counter, t3counter = 0, 0
    for config in configs:
        if (len(config)==4): # TODO: weak supposes telescope stations have 2 letters
            v2counter = v2counter + 1
            logger.info("Found v2 config {1}: {0} ".format(config, v2counter))
        elif (len(config)==6):  # weak supposes telescope stations have 2 letters
            t3counter = t3counter + 1            
            logger.info("Found t3 config {1}: {0} ".format(config, t3counter))
        else:
            # weak
            logger.info("Some oiblocks don't have a 2 letter naming convention for stations")
        oiconfv2 = [oi for oi in oiblocks if (oi['CONFIG']==config and oi['TYPE']=='V2')]
        oiconft3 = [oi for oi in oiblocks if (oi['CONFIG']==config and oi['TYPE']=='T3')]
        oiallconfsv2.append(oiconfv2)
        oiallconfst3.append(oiconft3)
        oiallconfsv2 = [oi for oi in oiallconfsv2 if oi != []]
        oiallconfst3 = [oi for oi in oiallconfst3 if oi != []]
    logger.info("Returning a 2 d list oibarr. oibarr[0] = {0} V2 oiblocks , oibarr[1] = {1} CP oiblocks ".format(v2counter, t3counter))
    return [oiallconfsv2, oiallconfst3]

def get_v2data(oiblocks):
    '''
    oi_get_v2data() 

    Extracts V2data from oibloc
    '''
    try:
        vis2data = list(filter(lambda x: x['TYPE'] == 'V2', oiblocks))
    except RuntimeError:
        logger.error("There is no V2 data in these oiblocks")
        return # FIXME: does not handle the absence of CP data should exit the function
    v2data = {key:"" for key in vis2data[0].keys()}
    for key in vis2data[0].keys():
        v2data[key] = np.array([v2[key] for v2 in vis2data])
    return v2data


def get_cpdata(oiblocks):
    """
    get_cpdatanew(oiblocks)
    """
    try:
        t3data = list(filter(lambda x: x['TYPE'] == 'T3', oiblocks))
    except RuntimeError:
        logger.error("There is no CP data in these oiblocks")
        return # FIXME: does not handle the absence of CP data should exit the function
    cpdata = {key:"" for key in t3data[0].keys()}
    for key in t3data[0].keys():
        cpdata[key] = np.array([cp[key] for cp in t3data])
    # max baseline of triangle
    mjd = np.array([t3['MJD'] for t3 in t3data])
    bpmax = np.array([max(t3['BP1'], t3['BP2'], t3['BP3'])
                    for t3 in t3data])
    # geometrical mean
    bpgeom = np.array([(t3['BP1'] * t3['BP2'] * t3['BP3'])**(1. /3.) for t3
                  in t3data])
    cpdata['BPMAX'] = bpmax
    cpdata['BPGEOM'] = bpgeom
    return cpdata
