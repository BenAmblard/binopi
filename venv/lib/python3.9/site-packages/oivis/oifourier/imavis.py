''' Computing visibility from an image.'''
import numpy as np
import os
datadir = os.path.dirname(os.path.abspath(__file__)) + "/../data/"

def ima_to_vis(ima, freq, pixsize, sigmul=0.015, sigadd=0.025):
    """ visib = visibility(ima, freq, pixsize, sigmul=0.015, sigadd=0.025)

    Computes the complex visibility of an image at the spatial frequencies freq
    with a global scaling factor pixsize.

    NB: freq and pixsize must be in corresponding units
    Typically freq in m/lambda and pix size in radians.
    WARNING: MCFOST provides pixel scale in degrees. Needs conversion

    NB2: ima needs to be normalised (i.e. divided by np.sum(ima)) if one wants
    the visibility normalised to one

    NB3: the noise models is based on Pionier's prescription (lazareff et al. 2016)
    noisedvis =visib .(1+ sigmul * (n1+in2))+ sigadd * (n3 +in4)

    freq = [ucoord/lambda, vcoord/lambdva]
    freq.shape: [2,nmeasurements]
    :sigmul: multiplicative noise (default 0.015 for Pionier)
    :sigadd: additive noise (default 0.025 for Pionier)

    """
    print("Multiplicative noise variance {0}".format(sigmul))
    print("Additive noise variance {0}".format(sigadd))
    visib = np.array([])
    dimima = ima.shape[0]
    ufreq, vfreq = freq[0], freq[1]
    # pdb.set_trace()
    imx = np.tile(np.arange(dimima) * pixsize, dimima).reshape(dimima, dimima)
    imy = np.transpose(imx)

    for i, u in enumerate(ufreq):
        coob = np.exp(-2j * np.pi * (imx * ufreq[i] + imy * vfreq[i]))
        coo3 = ima * coob
        visib = np.append(visib, np.sum(coo3, axis=(0, 1)))

    nmeas = visib.shape[0]
    n1 = np.random.normal(size=nmeas)
    n2 = np.random.normal(size=nmeas)
    n3 = np.random.normal(size=nmeas)
    n4 = np.random.normal(size=nmeas)
# using the visibility prescription (see Lazareff et al. 2015)
# noisedvis =visib .(1+0.015(n1+in2))+0.025*(n3 +in4)
    vc1 = n1 + 1j * n2
    vc2 = n3 + 1j * n4
    #noisedvisib = visib[np.newaxis, :] * (1 + sigmul * vc1[:, np.newaxis]) + sigadd * vc2[:, np.newaxis]
    noisedvisib = visib * (1 + sigmul * vc1) + sigadd * vc2
    return noisedvisib

def closurephase(ima, freq1, freq2, pixsize, sigmul=0.015, sigadd=0.025):
    """ t3 = closurephase(ima, freq1, freq2, pixsize)

    Computes the triple product of an image for the triangle of spatial frequencies
    defined by freq1 and freq1 with a global scaling factor pixsize.

    NB: freq and pixsize must be in corresponding units
    Typically freq in m/lambda and pixsize in radians

    freq1 = [u1coord/lambda, v1coord/lambda]
    freq2 = [u1coord/lambda, v1coord/lambda]

    EXAMPLE: Extracting the closure phase
    t3 = closurephase(imabin/np.sum(imabin), [ufreq1, vfreq1], [ufreq2, vfreq2], pixsize)
    t3phi = np.angle(t3) / np.pi *180  # conversion in degrees

    """
    visib1 = ima_to_vis(ima, freq1, pixsize, sigmul=sigmul, sigadd=sigadd)
    visib2 = ima_to_vis(ima, freq2, pixsize, sigmul=sigmul, sigadd=sigadd)
    co1 = freq1[0] + freq2[0]
    co2 = freq1[1] + freq2[1]
    visib3 = ima_to_vis(ima, [co1, co2], pixsize)

    return visib1 * visib2 * np.conjugate(visib3)