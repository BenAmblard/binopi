# useful functions for handling visibility functions
import numpy as np
import sys
from astropy.io import fits
thismod = sys.modules[__name__]


def radial_2d_grid(radius, sample, center=[0, 0]):

    x = np.linspace(-radius, radius, sample) + center[1]
    y = np.linspace(-radius, radius, sample) + center[0]
    xi1 = np.tile(x, sample)
    xx = xi1.reshape(sample, sample)
    yi1 = np.repeat(y, sample)
    yy = yi1.reshape(sample, sample)
    radgrid = np.sqrt(xx**2+yy**2)
    return xi1, yi1, radgrid

def vis_grid(bmax, gridim, wavel, params, funcname):
    """
    visgrid = vis_grid(bmax, gridim, wavel, params, funcname):

    Computes an image of the Fourier space visibility and direct
    space image on a grid of maximum spatial frequency bmax/wavel and
    numerical size gridim. 
    
    Parameters
    ----------
    
    bmax : float (meters)
        Maximum baseline used in the grid
    gridim : integer
        Number of cells in the (radial) grid
    wavel: float (meters)
        Wavelength of observation
    params : dictionary 
        parameters to define the visibility function
    funcname : function call (from functions.py)
        Visibility function to visualise (e.g vis_sinusoidal_ring)
    
    Returns
    -------
    
    visgrid['xi1'] : Radial grid in the x direction

    visgrid['yi1'] : Radial grid in the y direction

    visgrid['visibility'] : Complex array of dim gridim x gridim containing
        the visibility of funcname with parameters param

    visgrid['image'] = Array of dim gridim x gridm containing the
        fourier transform of the visibility.

     An example::
        visgrid = visfuncs.vis_grid(250, 250, 1.65e-6, params, combine_functions)

    """
    # computing the radial grid
    # xi1 and yi1 are the spatial frequencies grid for each direction
    xi1, yi1, radgrid = radial_2d_grid(bmax, gridim)
    # converting function name string into a real function
    #JPB visfunc = getattr(thismod, funcname)
    # spatial frequency array
    x = [xi1, yi1, wavel, wavel]
    # computing the visibility
    # JPB vis = visfunc(x, params)
    vis = funcname(x, params)
    # reshaping and ft to get the proper ft and direct image of the
    # objects
    visgrid = vis['VIS'].reshape(gridim, gridim)
    tfvis = np.fft.fft2(visgrid)
    modtf = np.fft.fftshift(np.absolute(tfvis))
    modima = modtf[::-1, ::]#np.transpose(modtf[::-1, ::]) 
    visimage = {}
    visimage['xi1'] = xi1
    visimage['yi1'] = yi1
    visimage['VIS'] = visgrid
    visimage['IMAGE'] = modtf

    return visimage

def vis_cube(bmax, gridim, wavels, params, funcname):
    """Creates a cube corresponding to the observations at multiple wavelengths"""

    return np.array([vis_grid(bmax, gridim, wavel, params, funcname)['IMAGE'] for wavel in wavels])

def save_to_fits(cube, pxscale, dim, wl, fits_path):
    """Save cube to a fits file, TODO merge with vis_cube and vis_grid"""
    #shift arrays to match fits definition of origin that is different to that of python
    cube = np.array([cube[i,::-1,::-1] for i in range(len(cube))])
    hdu = fits.PrimaryHDU(cube)
    hdu.header['CDELT1'] = pxscale
    hdu.header['CDELT2'] = pxscale
    hdu.header['CRVAL1'] = 0
    hdu.header['CRVAL2'] = 0
    hdu.header['CRPIX1'] = dim/2
    hdu.header['CRPIX2'] = dim/2
    hdu.header['CUNIT1'] = "rad"
    hdu.header['CUNIT2'] = "rad"
    hdu.header['CROTA1'] = 0
    hdu.header['CROTA2'] = 0

    # Wavelength axis TODO Add a conditional statement, with time axis as well
    naxis = 3
    hdu.header[f'CDELT{naxis}'] = wl[1]-wl[0]
    hdu.header[f'CRPIX{naxis}'] = 1
    hdu.header[f'CRVAL{naxis}'] = wl[0]
    hdu.header[f'CUNIT{naxis}'] = "m"

    hdu.writeto(fits_path, overwrite=True)